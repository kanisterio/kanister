.. _architecture:

Architecture
************

.. contents:: Architecture
  :local:


Kopia Repository Server Workflow
================================

Introducing Kopia
------------------

Kopia is a powerful, cross-platform tool for managing encrypted backups
in the cloud. It provides fast and secure backups, using compression,
data `de-duplication`, and client-side end-to-end encryption. It supports
a variety of backup storage targets, including object stores, which allows
users to choose the storage provider that better addresses their needs.
In Kopia, these storage locations are called repositories. It is a
lock-free system that allows concurrent multi-client operations,
including garbage collection. To explore other features of Kopia,
see its `documentation <https://kopia.io/docs/features/>`_

Kopia Repository Server
-----------------------

A Kopia Repository Server allows Kopia clients to proxy access to the backend storage
location through it. At any time, a repository server can only connect to a single
repository. Due to this limitation, a separate instance of the server will be used
for each repository.

In Kanister, the server will comprise of a Kubernetes pod and service. The pod runs
the Kopia repository server process that will be used by Kopia clients to perform
backup and restore operations. Kopia clients would only need a username/password and
service name to connect to server without the need to know the backend storage
location. This approach provides enhanced security since only authorized users will be
allowed to access the Kopia repository server. These authorized users need to be
added to the server before starting the server.

Kopia Repository
----------------

The backup storage location is called a "Repository" in Kopia. Only a single
repository can exist at a particular path in the backend storage location.
Users opting to use separate repositories are recommended to use unique path
prefixes for each repository. For example, a repository for a namespace called
monitoring on an S3 storage bucket called test-bucket could be created at the
location ``s3://test-bucket/<UUID of monitoring namespace>/repo/``. Accessing
the repository requires the storage location and credential information similar
to a Kanister Profile CR and a unique password used by Kopia during encryption,
along with the unique path prefix mentioned above.

To know more about the design of the Kopia repository server controller refer to
its `design documentation <https://github.com/kanisterio/kanister/blob/master/design/kanister-kopia-integration.md>` _

The design of Kanister follows the operator pattern. This means
Kanister defines its own resources and interacts with those resources
through a controller. `This blog post
<https://www.redhat.com/en/blog/operators-over-easy-introduction-kubernetes-operators>`_ describes the
pattern in detail.

In particular, Kanister is composed of three main components: the
Controller and two Custom Resources - ActionSets and Blueprints.  The
diagram below illustrates their relationship and how they fit
together:

   .. image:: ./_static/kanister_workflow.png


Kanister Workflow
=================

As seen in the above diagram and described in detail below, all
Kanister operations are declarative and require an ActionSet to be
created by the user. Once the ActionSet is detected by the Kanister
controller, it examines the environment for Blueprint referenced in
the ActionSet (along with other required configuration). If all
requirements are satisfied, it will then use the discovered Blueprint
to complete the action (e.g., backup) specified in the
ActionSet. Finally, the original ActionSet will be updated by the
controller with status and other metadata generated by the action
execution.


Custom Resources
================

Users interact with Kanister through Kubernetes resources known as
CustomResources (CRs). When the controller starts, it creates the CR
definitions called CustomResourceDefinitions (CRDs).  `CRDs
<https://kubernetes.io/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/>`_
were introduced in Kubernetes 1.7 and replaced TPRs. The lifecycle of these
objects can be managed entirely through kubectl. Kanister uses Kubernetes' code
generation tools to create go client libraries for its CRs.

The schemas of the Kanister CRDs can be found in `types.go
<https://github.com/kanisterio/kanister/tree/master/pkg/apis/cr/v1alpha1/types.go>`_ and
`repositoryserver_types.go <https://github.com/kanisterio/kanister/tree/master/pkg/apis/cr/v1alpha1/repositoryserver_types.go>`_

Blueprints
----------

Blueprint CRs are a set of instructions that tell the controller how to perform
actions on a specific application.

A Blueprint contains a field called ``Actions`` which is a mapping of Action Name
to ``BlueprintAction``.

The definition of a ``BlueprintAction`` is:

.. code-block:: go
  :linenos:

  // BlueprintAction describes the set of phases that constitute an action.
  type BlueprintAction struct {
      Name               string              `json:"name"`
      Kind               string              `json:"kind"`
      ConfigMapNames     []string            `json:"configMapNames"`
      SecretNames        []string            `json:"secretNames"`
      InputArtifactNames []string            `json:"inputArtifactNames"`
      OutputArtifacts    map[string]Artifact `json:"outputArtifacts"`
      Phases             []BlueprintPhase    `json:"phases"`
      DeferPhase         *BlueprintPhase     `json:"deferPhase,omitempty"`
  }

- ``Kind`` represents the type of Kubernetes object this BlueprintAction is written for.
  Specifying this is optional and going forward, if this is specified, Kanister will
  enforce that it matches the ``Object`` kind specified in an ActionSet referencing this
  BlueprintAction
- ``ConfigMapNames``, ``SecretNames``, ``InputArtifactNames`` are optional
  but, if specified, they list named parameters that must be included by
  the ``ActionSet``.
- ``OutputArtifacts`` is an optional map of rendered parameters made available
  to the ``BlueprintAction``.
- ``Phases`` is a required list of ``BlueprintPhases``. These phases are invoked
  in order when executing this Action.
- ``DeferPhase`` is an optional ``BlueprintPhase`` invoked after the
  execution of ``Phases`` defined above. A ``DeferPhase``, when specified,
  is executed regardless of the statuses of the ``Phases``.
  A ``DeferPhase`` can be used for cleanup operations at the end of an ``Action``.

.. code-block:: go
  :linenos:

  // BlueprintPhase is a an individual unit of execution.
  type BlueprintPhase struct {
      Func       string                     `json:"func"`
      Name       string                     `json:"name"`
      ObjectRefs map[string]ObjectReference `json:"objects"`
      Args       map[string]interface{}     `json:"args"`
  }

- ``Func`` is required as the name of a registered Kanister function.
  See :ref:`functions` for the list of  functions supported by the controller.
- ``Name`` is mostly cosmetic. It is useful in quickly identifying which
  phases the controller has finished executing.
- ``Object`` is a map of references to the Kubernetes objects on which
  the action will be performed.
- ``Args`` is a map of named arguments that the controller will pass to
  the Kanister function.
  String argument values can be templates that the controller will
  render using the template parameters. Each argument is rendered
  individually.

As a reference, below is an example of a BlueprintAction.

.. code-block:: yaml
  :linenos:

  actions:
    example-action:
      phases:
      - func: KubeExec
        name: examplePhase
        args:
          namespace: "{{ .Deployment.Namespace }}"
          pod: "{{ index .Deployment.Pods 0 }}"
          container: kanister-sidecar
          command:
            - bash
            - -c
            - |
              echo "Example Action"

.. _actionsets:

ActionSets
----------

Creating an ActionSet instructs the controller to run an action now.
The user specifies the runtime parameters inside the spec of the ActionSet.
Based on the parameters, the Controller populates the Status of the object,
executes the actions, and updates the ActionSet's status.

An ActionSetSpec contains a list of ActionSpecs. An ActionSpec is defined
as follows:

.. code-block:: go
 :linenos:

  // ActionSpec is the specification for a single Action.
  type ActionSpec struct {
      Name string                           `json:"name"`
      Object ObjectReference                `json:"object"`
      Blueprint string                      `json:"blueprint,omitempty"`
      Artifacts map[string]Artifact         `json:"artifacts,omitempty"`
      ConfigMaps map[string]ObjectReference `json:"configMaps"`
      Secrets map[string]ObjectReference    `json:"secrets"`
      Options map[string]string             `json:"options"`
      Profile *ObjectReference              `json:"profile"`
      PodOverride map[string]interface{}    `json:"podOverride,omitempty"`
  }

- ``Name`` is required and specifies the action in the Blueprint.
- ``Object`` is a required reference to the Kubernetes object on which
  the action will be performed.
- ``Blueprint`` is a required name of the Blueprint that contains the
   action to run.
- ``Artifacts`` are input Artifacts passed to the Blueprint. This must
  contain an Artifact for each name listed in the BlueprintAction's
  InputArtifacts.
- ``ConfigMaps`` and ``Secrets``, similar to ``Artifacts``, are a mappings of names
  specified in the Blueprint referencing the Kubernetes object to be used.
- ``Profile`` is a reference to a :ref:`Profile<profiles>` Kubernetes
  CustomResource that will be made available to the Blueprint.
- ``Options`` is used to specify additional values to be used in the Blueprint
- ``PodOverride`` is used to specify pod specs that will override default specs
  of the Pod created while executing functions like KubeTask, PrepareData, etc.

As a reference, below is an example of a ActionSpec.

.. code-block:: yaml
  :linenos:

  spec:
    actions:
    - name: example-action
      blueprint: example-blueprint
      object:
        kind: Deployment
        name: example-deployment
        namespace: example-namespace
      profile:
        apiVersion: v1alpha1
        kind: profile
        name: example-profile
        namespace: example-namespace

In addition to the Spec, an ActionSet also contains an ActionSetStatus
which mirrors the Spec, but contains the phases of execution, their
state, and the overall execution progress.

.. code-block:: go

  // ActionStatus is updated as we execute phases.
  type ActionStatus struct {
      Name string                   `json:"name"`
      Object ObjectReference        `json:"object"`
      Blueprint string              `json:"blueprint"`
      Phases []Phase                `json:"phases"`
      Artifacts map[string]Artifact `json:"artifacts"`
  }

Unlike in the ActionSpec, the Artifacts in the ActionStatus are the rendered
output artifacts from the Blueprint. These are rendered and populated once the action is complete.


Each phase in the ActionStatus phases list contains the phase name of the
Blueprint phase along with its state of execution and output.

.. code-block:: go

  // Phase is subcomponent of an action.
  type Phase struct {
      Name   string                 `json:"name"`
      State  State                  `json:"state"`
      Output map[string]interface{} `json:"output"`
  }


Deleting an ActionSet will cause the controller to delete the ActionSet,
which will stop the execution of the actions.

.. code-block:: bash

  $ kubectl --namespace kanister delete actionset s3backup-j4z6f
    actionset.cr.kanister.io "s3backup-j4z6f" deleted

.. note::
    Since ActionSets are ``Custom Resources``, Kubernetes allows users to delete them like any other API objects.
    Currently, *deleting* an ActionSet to stop execution is an **alpha** feature.

.. _profiles:

Profiles
--------

Profile CRs capture information about a location for data operation artifacts
and corresponding credentials that will be made available to a Blueprint.

The definition of a ``Profile`` is:

.. code-block:: go
  :linenos:

  // Profile
  type Profile struct {
    Location          Location   `json:"location"`
    Credential        Credential `json:"credential"`
    SkipSSLVerify     bool       `json:"skipSSLVerify"`
  }

- ``SkipSSLVerify`` is boolean and specifies whether skipping SkipSSLVerify
  verification is allowed when operating with the ``Location``. If omitted from
  a CR definition it default to ``false``
- ``Location`` is required and used to specify the location that the Blueprint
  can use. Currently, only s3 compliant locations are supported. If any of
  the sub-components are omitted, they will be treated as "".

  The definition of ``Location`` is as follows:

.. code-block:: go
  :linenos:

  // LocationType
  type LocationType string

  const (
    LocationTypeGCS         LocationType = "gcs"
    LocationTypeS3Compliant LocationType = "s3Compliant"
    LocationTypeAzure       LocationType = "azure"
  )

  // Location
  type Location struct {
    Type     LocationType `json:"type"`
    Bucket   string       `json:"bucket"`
    Endpoint string       `json:"endpoint"`
    Prefix   string       `json:"prefix"`
    Region   string       `json:"region"`
  }

- ``Credential`` is required and used to specify the credentials associated with
  the ``Location``. Currently, only key pair s3, gcs and azure location credentials are
  supported.

  The definition of ``Credential`` is as follows:

.. code-block:: go
  :linenos:

  // CredentialType
  type CredentialType string

  const (
    CredentialTypeKeyPair CredentialType = "keyPair"
  )

  // Credential
  type Credential struct {
    Type    CredentialType `json:"type"`
    KeyPair *KeyPair       `json:"keyPair"`
  }

  // KeyPair
  type KeyPair struct {
    IDField     string          `json:"idField"`
    SecretField string          `json:"secretField"`
    Secret      ObjectReference `json:"secret"`
  }

- ``IDField`` and ``SecretField`` are required and specify the corresponding
  keys in the secret under which the ``KeyPair`` credentials are stored.
- ``Secret`` is required reference to a Kubernetes Secret object storing the
  ``KeyPair`` credentials.

As a reference, below is an example of a Profile and the corresponding secret.

.. code-block:: yaml
  :linenos:

  apiVersion: cr.kanister.io/v1alpha1
  kind: Profile
  metadata:
    name: example-profile
    namespace: example-namespace
  location:
    type: s3Compliant
    bucket: example-bucket
    endpoint: <endpoint URL>:<port>
    prefix: ""
    region: ""
  credential:
    type: keyPair
    keyPair:
      idField: example_key_id
      secretField: example_secret_access_key
      secret:
        apiVersion: v1
        kind: Secret
        name: example-secret
        namespace: example-namespace
  skipSSLVerify: true
  ---
  apiVersion: v1
  kind: Secret
  type: Opaque
  metadata:
    name: example-secret
    namespace: example-namespace
  data:
    example_key_id: <access key>
    example_secret_access_key: <access secret>

.. _repository_servers:

RepositoryServers
-----------------

RepositoryServer CR is required by the repository server controller to start
a Kopia repository server. The CR has a list of parameters to configure
the Kopia repository server.

.. note::
    Secrets referenced in the CR should be created in the format referenced
    in the :ref:`Repository Server Secrets<repository_server_secrets>` section


The definition of ``Repository Server`` is:

.. code-block:: go
  :linenos:

  // RepositoryServer manages the lifecycle of Kopia Repository Server within a Pod
  type RepositoryServer struct {
    metav1.TypeMeta   `json:",inline"`
    metav1.ObjectMeta `json:"metadata,omitempty"`
    Spec RepositoryServerSpec `json:"spec"`
    Status RepositoryServerStatus `json:"status"`
  }

  Repository Server ``Spec`` field is defined as follows:

.. code-block:: go
  :linenos:

  type RepositoryServerSpec struct {
    Storage Storage `json:"storage"`
    Repository Repository `json:"repository"`
    Server Server `json:"server"`
  }

- The ``Storage`` field in the ``RepositoryServerSpec`` contains the location
  details where the Kopia repository is created

.. code-block:: go
  :linenos:

  type Storage struct {
    SecretRef corev1.SecretReference `json:"secretRef"`
    CredentialSecretRef corev1.SecretReference `json:"credentialSecretRef"`
  }

^ ``SecretRef`` and ``CredentialSecretRef`` are the references to location
  secrets

- ``Repository`` field in CR ``spec`` has details to connect to Kopia repository created
  in the above location storage

.. code-block:: go
  :linenos:

  type Repository struct {
    RootPath string `json:"rootPath"`
    Username string `json:"username"`
    Hostname string `json:"hostname"`
    PasswordSecretRef corev1.SecretReference `json:"passwordSecretRef"`
    CacheSizeSettings CacheSizeSettings      `json:"cacheSizeSettings,omitempty"`
  }


^ ``RootPath`` is the path for the Kopia repository. It is the sub-path within
the path prefix specified in the storage location
^ ``Username`` is an optional field used to override the default username while
connecting to the Kopia repository
^ ``Hostname`` is an optional field used to override the default host name while
connecting to the Kopia repository

Kopia identifies users by ``username@hostname`` and uses the values
specified when establishing a connection to the repository to identify
backups created in the session.


^ ``PasswordSecretRef`` is the reference to the secret containing the password to
connect to the Kopia repository
^ ``CacheSizeSettings`` is an optional field used to specify the size of the different
caches for the Kopia repository. If not specified, default cache settings are used
by repository server controller

To know more about the Kopia caches, refer to the `Kopia caching documentation <https://kubernetes.io/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/>`_`

.. code-block:: go
  :linenos:

  type CacheSizeSettings struct {
    Metadata string `json:"metadata"`
    Content  string `json:"content"`
  }

- ``Server`` field in the CR spec has references to all the secrets
  required to start the Kopia repository server

.. code-block:: go
  :linenos:

  type Server struct {
    UserAccess UserAccess `json:"userAccess"`
    AdminSecretRef corev1.SecretReference `json:"adminSecretRef"`
    TLSSecretRef corev1.SecretReference `json:"tlsSecretRef"`
  }

^ ``AdminSecretRef`` is a secret reference containing admin credentials
  required to start the Kopia repository server

^ ``TLSSecretRef`` is a TLS secret reference for Kopia client and server communication

^ ``UserAccess`` contains username and password secret reference required
  for creating Kopia repository server users.

.. code-block:: go
  :linenos:

  type UserAccess struct {
    UserAccessSecretRef corev1.SecretReference `json:"userAccessSecretRef"`
    Username string `json:"username"`
  }


- ``Status`` field in ``RepositoryServer`` CR is used by repository server controller
  to propagate server's status to the client. It is defined as:

.. code-block:: go
  :linenos:

  type RepositoryServerStatus struct {
    Conditions []metav1.Condition       `json:"conditions,omitempty"`
    ServerInfo ServerInfo               `json:"serverInfo,omitempty"`
    Progress   RepositoryServerProgress `json:"progress"`
  }

- ``Progress`` is populated by controller with 3 values

  ^ ``Ready`` represents the ready state of the repository server and
  the pod, which runs the proxy server

  ^ ``Failed`` represents that the controller got an error while
  starting the repository server

  ^ ``Pending`` represents that the repository server is yet to be completely started

- ``ServerInfo`` is populated by the repository server controller with
  the server details that the client requires to connect to the server

.. code-block:: go
  :linenos:

  type ServerInfo struct {
    PodName     string `json:"podName,omitempty"`
    ServiceName string `json:"serviceName,omitempty"`
  }

^ ``PodName`` is the name of the pod created by controller for Kopia repository server

^ ``ServiceName`` is the name of the Kubernetes service created by the controller
which contains the connection details for the repository server


As a reference, below is an example of a Repository Server

.. code-block:: yaml
  :linenos:

  apiVersion: cr.kanister.io/v1alpha1
  kind: RepositoryServer
  metadata:
    name: kopia-repo-server
    namespace: <controller-namespace>
  spec:
    storage:
      secretRef:
        name: <location-secret>
        namespace: <controller-namespace>
      credentialSecretRef:
        name: <credentials-secret>
        namespace: <controller-namespace>
    repository:
      rootPath: <repo-path>
      passwordSecretRef:
        name: <repo-pass-secret>
        namespace: <controller-namespace>
      username: <username-to-connect-repository>
      hostname: <hostname-to-connect-repository>
    server:
      adminSecretRef:
        name: <server-admin-username-secret>
        namespace: <controller-namespace>
      tlsSecretRef:
        name: <server-tls-cert-secret>
        namespace: <controller-namespace>
      userAccess:
        userAccessSecretRef:
          name: <server-user-password-secret>
          namespace: <controller-namespace>
        username: <server-user>

.. _repository_Server_secrets:

Repository Server Secrets
=========================

The repository server controller needs the following secrets to be created for starting the Kopia
repository server successfully. The secrets are referenced in the ``RepositoryServer``
CR, as described in  :ref:`RepositoryServer<repository_servers>`.

Location Storage Secret
-----------------------

This secret stores the sensitive details of the location where the Kopia
repository is created. This secret is referenced by ``spec.storage.secretRef``
field in the repository server CR.

The ``data.type`` field can have following values ``s3``, ``gcs``,
``azure``, ``file-store``

.. code-block:: yaml
  :linenos:

  apiVersion: v1
  kind: Secret
  metadata:
     name: location
     namespace: <controller-namespace>
  type: secrets.kanister.io/storage-location
  data:
     # required: specify the type of the store
     # supported values are s3, gcs, azure, and file-store
     type: <base-64-encoded-value>
     # required
     bucket: <base-64-encoded-value>
     # optional: specified in case of S3-compatible stores
     endpoint: <base-64-encoded-value>
     # optional: used as a sub path in the bucket for all backups
     path: <base-64-encoded-value>
     # required, if supported by the provider
     region: <base-64-encoded-value>
     # required: if type is `file-store`
     # optional, otherwise
     claimName: <base-64-encoded-value>

Location Credentials Secret
---------------------------

The following secret should be used for Azure, AWS and GCS storage credentials.
This secret is referenced by the ``spec.storage.credentialSecretRef`` in the repository server
CR:

- ``AWS S3``

.. code-block:: yaml
  :linenos:

  apiVersion: v1
  kind: Secret
  metadata:
     name: s3-loc-creds
     namespace: <controller-namespace>
  type: secrets.kanister.io/aws
  data:
     # required: base64 encoded value for key with proper permissions for the bucket
     access-key: <redacted>
     # required: base64 encoded value for the secret corresponding to the key above
     secret-acccess-key: <redacted>
     # optional: base64 encoded value for AWS IAM role
     role: <redacted>

- ``Azure``

.. code-block:: yaml
  :linenos:

  apiVersion: v1
  kind: Secret
  metadata:
     name: s3-loc-creds
     namespace: <controller-namespace>
  type: secrets.kanister.io/aws
  data:
    # required: base64 encoded value for account with proper permissions for the bucket
     azure_storage_account_id: <redacted>
     # required: base64 encoded value for the key corresponding to the account above
     azure_storage_key: <redacted>
     # optional: base64 encoded value for the storage enevironment.
     # Acceptable values are AzureCloud, AzureChinaCloud, AzureUSGovernment, AzureGermanCloud
     azure_storage_environment: <redacted>

- ``GCS``

  .. code-block:: yaml
    :linenos:

    apiVersion: v1
    kind: Secret
    metadata:
       name: gcs-loc-creds
       namespace: <controller-namespace>
    type: secrets.kanister.io/gcp
    data:
       # required: base64 encoded value for project with proper permissions for the bucket
       project-id: <redacted>
       # required: base64 encoded value for the SA with proper permissions for the bucket.
       # This value is base64 encoding of the service account json file when
       # creating a new service account
       service-account.json: <base64 encoded SA json file>


Repository Password Secret
--------------------------
This is the password secret used by controller to connect to Kopia repository. It
is referenced by the ``spec.repository.passwordSecretRef`` in the repository server CR.

.. code-block:: yaml
  :linenos:

  apiVersion: v1
  kind: Secret
  metadata:
     name: repository-password
     namespace: <controller-namespace>
  type: secrets.kanister.io/kopia-repository/password
  data:
     repo-password: <redacted>

Repository Server Admin User Secret
-----------------------------------
This secret is used for storing admin credentials that are used by the controller
to start the Kopia repository server. It is referenced by the ``spec.server.accessSecretRef``
in the repository server CR.

.. code-block:: yaml
  :linenos:

  apiVersion: v1
  kind: Secret
  metadata:
     name: repository-server-admin
     namespace: <controller-namespace>
  type: secrets.kanister.io/kopia-repository/serveradmin
  data:
     username: <redacted>
     password: <redacted>


TLS Secret
----------

This secret stores TLS sensitive data used for Kopia client server communication.
It follows the standard ``kubernetes.io/tls``. It is referenced by the
``spec.server.tlsSecretRef`` in the repository server CR.

.. code-block:: yaml
  :linenos:

  apiVersion: v1
  kind: Secret
  metadata:
   name: repository-server-tls
   namespace: <controller-namespace>
  type: kubernetes.io/tls
  data:
   tls.crt: |
      <redacted>
   tls.key: |
      <redacted>


Repository Server User Access Password Secret
---------------------------------------------
The Kopia repository client needs an access username and password for authentication to
connect to Kopia repository server.

The Kopia client needs a user in the format of ``<username>@<hostname>``. The username is 
the same for all the clients, which is specified in ``spec.server.UserAccess.username`` of
the ``RepositoryServer`` CR. The password and host name are provided in the form of
a secret, as shown below

.. code-block:: yaml
  :linenos:

   apiVersion: v1
   kind: Secret
   metadata:
     name: repository-server-user-access
     namespace: kanister
   type: secrets.kanister.io/kopia-repository/serveruser
   data:
     <hostname1>: <redacted-password>
     <hostname2>: <redacted-password>


Controller
==========

The Kanister controller is a Kubernetes Deployment and is installed easily using
``kubectl``. See :ref:`install` for more information on deploying the controller.

Execution Walkthrough
---------------------

The controller watches for new/updated ActionSets in the same namespace in which
it is deployed. When it sees an ActionSet with a nil status field, it
immediately initializes the ActionSet's status to the Pending State. The status is
also prepopulated with the pending phases.

Execution begins by resolving all the :ref:`templates`. If any required
object references or artifacts are missing from the ActionSet, the ActionSet
status is marked as failed. Otherwise, the template params are used to render the
output Artifacts, and then the args in the Blueprint.

For each action, all phases are executed in-order. The rendered args are
passed to :ref:`templates` which correspond to a single phase. When a phase
completes, the status of the phase is updated. If any single phase fails, the
entire ActionSet is marked as failed.  Upon failure, the controller ceases
execution of the ActionSet.

Within an ActionSet, individual Actions are run in parallel.

Currently the user is responsible for cleaning up ActionSets once they complete.

During execution, Kanister controller emits events to the respective ActionSets.
In above example, the execution transitions of ActionSet ``s3backup-j4z6f`` can be
seen by using the following command:

.. code-block:: bash

  $ kubectl --namespace kanister describe actionset s3backup-j4z6f
  Events:
    Type    Reason           Age   From                 Message
    ----    ------           ----  ----                 -------
    Normal  Started Action   23s   Kanister Controller  Executing action backup
    Normal  Started Phase    23s   Kanister Controller  Executing phase backupToS3
    Normal  Update Complete  19s   Kanister Controller  Updated ActionSet 's3backup-j4z6f' Status->complete
    Normal  Ended Phase      19s   Kanister Controller  Completed phase backupToS3
